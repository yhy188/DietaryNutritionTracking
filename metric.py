import numpy as np
import cv2
import os
from natsort import ns, natsorted
import matplotlib.pyplot as plt
import pandas as pd


# Note that the prediction map should maintain the same channels and size as the original image.
def calculate_metrics(predict_image, gt_image):
    predict_image = np.array(predict_image, dtype=bool)/255
    gt_image = np.array(gt_image, dtype=bool)
    # True Positive（TP）
    tp = np.sum(np.logical_and(predict_image, gt_image))
    # True Negative（TN）
    tn = np.sum(np.logical_and(np.logical_not(predict_image), np.logical_not(gt_image)))
    # False Positive（FP）
    fp = np.sum(np.logical_and(predict_image, np.logical_not(gt_image)))
    # False Negative（FN）
    fn = np.sum(np.logical_and(np.logical_not(predict_image), gt_image))
    # Accuracy
    accuracy = (tp + tn) / (tp + fp + tn + fn + 1e-7)
    # precision
    precision = tp / (tp + fp + 1e-7)
    return [ accuracy, precision]


def evaluate1(label_path, pre_path, num_images_per_epoch=231):
    # Initialize lists to store metrics for each epoch
    epoch_accuracy_means = []
    epoch_precision_means = []

    pre_imgs = os.listdir(pre_path)
    pre_imgs = natsorted(pre_imgs, alg=ns.PATH)
    lab_imgs = os.listdir(label_path)
    lab_imgs = natsorted(lab_imgs, alg=ns.PATH)

    # Process images in batches corresponding to epochs
    for epoch in range(300):
        accuracy_list = []
        precision_list = []

        # Calculate metrics for each image in the epoch
        for i in range(num_images_per_epoch):
            index = epoch * num_images_per_epoch + i
            if index >= len(pre_imgs):
                break  # In case there are fewer images than expected

            imgPredict = cv2.imread(pre_path + "\\" + pre_imgs[index])
            imgLabel = cv2.imread(label_path + "\\" + lab_imgs[index])
            imgPredict = np.array(cv2.cvtColor(imgPredict, cv2.COLOR_BGR2GRAY), dtype=np.uint8)
            imgLabel = np.array(cv2.cvtColor(imgLabel, cv2.COLOR_BGR2GRAY), dtype=np.uint8)
            value = calculate_metrics(imgLabel, imgPredict)
            accuracy_list.append(value[0])
            precision_list.append(value[1])

        # Calculate mean of metrics for the current epoch
        epoch_accuracy_mean = np.mean(accuracy_list)
        epoch_precision_mean = np.mean(precision_list)

        # Store the mean values
        epoch_accuracy_means.append(epoch_accuracy_mean)
        epoch_precision_means.append(epoch_precision_mean)

    # Output the mean metrics for each epoch
    print("Epoch Accuracy Means:", epoch_accuracy_means)
    print("Epoch Precision Means:", epoch_precision_means)

    # Plot the mean metrics for each epoch
    plt.figure(figsize=(12, 6))
    plt.plot(range(1, 301), epoch_accuracy_means, label='Accuracy')
    plt.xlabel('Epoch')
    plt.ylabel('Mean Value')
    plt.title('Epoch-wise Mean Accuracy')
    plt.legend()
    plt.grid(True)
    plt.show()

    plt.figure(figsize=(12, 6))
    plt.plot(range(1, 301), epoch_precision_means, label='Precision')
    plt.xlabel('Epoch')
    plt.ylabel('Mean Value')
    plt.title('Epoch-wise Mean Precision')
    plt.legend()
    plt.grid(True)
    plt.show()

    # Optionally, save the mean metrics to CSV files
    pd.DataFrame(epoch_accuracy_means).to_csv('./csv_dictor/epoch_accuracy_means.csv', header=False, index=False)
    pd.DataFrame(epoch_precision_means).to_csv('./csv_dictor/epoch_precision_means.csv', header=False, index=False)


# Call the function with the paths to the prediction and label directories
# If you want to compare accuracy, precision, and loss, you need to add new data to the plot,
# which is still generated by the code. You just need to organize the data.

if __name__ == '__main__':
    pre_path = 'D:\\U-Net2\\pytorch-unet-master\\accuracy_data\\DSC_out'
    label_path = 'D:\\U-Net2\\pytorch-unet-master\\accuracy_data\\DSC_label'
    evaluate1(label_path, pre_path)
